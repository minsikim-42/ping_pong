{"version":3,"names":["chmod","src","dest","fs","chmodSync","statSync","mode","err","console","warn","readdir","dirname","includeDotfiles","filter","readdirRecursive","filename","index","currentDirectory","stat","path","join","isDirectory","readdirForCompilable","altExts","isCompilableExtension","exts","babel","DEFAULT_EXTENSIONS","ext","extname","includes","addSourceMappingUrl","code","loc","basename","hasDataSourcemap","pos","lastIndexOf","length","CALLER","name","transformRepl","opts","caller","Promise","resolve","reject","transform","result","compile","transformFile","externalDependencies","watcher","updateExternalDependencies","deleteDir","existsSync","readdirSync","forEach","file","curPath","lstatSync","unlinkSync","rmdirSync","process","on","error","exitCode","withExtension","newBasename","debounce","fn","time","timer","debounced","clearTimeout","setTimeout","flush"],"sources":["../../src/babel/util.ts"],"sourcesContent":["import readdirRecursive from \"fs-readdir-recursive\";\nimport * as babel from \"@babel/core\";\nimport path from \"path\";\nimport fs from \"fs\";\n\nimport * as watcher from \"./watcher\";\n\nimport type { FileResult, InputOptions } from \"@babel/core\";\n\nexport function chmod(src: string, dest: string): void {\n  try {\n    fs.chmodSync(dest, fs.statSync(src).mode);\n  } catch (err) {\n    console.warn(`Cannot change permissions of ${dest}`);\n  }\n}\n\ntype ReaddirFilter = (filename: string) => boolean;\n\nexport function readdir(\n  dirname: string,\n  includeDotfiles: boolean,\n  filter?: ReaddirFilter,\n): Array<string> {\n  return readdirRecursive(dirname, (filename, index, currentDirectory) => {\n    const stat = fs.statSync(path.join(currentDirectory, filename));\n\n    if (stat.isDirectory()) return true;\n\n    return (\n      (includeDotfiles || filename[0] !== \".\") && (!filter || filter(filename))\n    );\n  });\n}\n\nexport function readdirForCompilable(\n  dirname: string,\n  includeDotfiles: boolean,\n  altExts?: Array<string>,\n): Array<string> {\n  return readdir(dirname, includeDotfiles, function (filename) {\n    return isCompilableExtension(filename, altExts);\n  });\n}\n\n/**\n * Test if a filename ends with a compilable extension.\n */\nexport function isCompilableExtension(\n  filename: string,\n  altExts?: readonly string[],\n): boolean {\n  const exts = altExts || babel.DEFAULT_EXTENSIONS;\n  const ext = path.extname(filename);\n  return exts.includes(ext);\n}\n\nexport function addSourceMappingUrl(code: string, loc: string): string {\n  return code + \"\\n//# sourceMappingURL=\" + path.basename(loc);\n}\n\nexport function hasDataSourcemap(code: string): boolean {\n  const pos = code.lastIndexOf(\"\\n\", code.length - 2);\n  return pos != -1 && code.lastIndexOf(\"//# sourceMappingURL\") < pos;\n}\n\nconst CALLER = {\n  name: \"@babel/cli\",\n};\n\nexport function transformRepl(filename: string, code: string, opts: any) {\n  opts = {\n    ...opts,\n    caller: CALLER,\n    filename,\n  };\n\n  return new Promise<FileResult>((resolve, reject) => {\n    babel.transform(code, opts, (err, result) => {\n      if (err) reject(err);\n      else resolve(result);\n    });\n  });\n}\n\nexport async function compile(filename: string, opts: InputOptions) {\n  opts = {\n    ...opts,\n    caller: CALLER,\n  };\n\n  // TODO (Babel 8): Use `babel.transformFileAsync`\n  const result = await new Promise<FileResult>((resolve, reject) => {\n    babel.transformFile(filename, opts, (err, result) => {\n      if (err) reject(err);\n      else resolve(result);\n    });\n  });\n\n  if (result) {\n    if (!process.env.BABEL_8_BREAKING) {\n      if (!result.externalDependencies) return result;\n    }\n    watcher.updateExternalDependencies(filename, result.externalDependencies);\n  }\n\n  return result;\n}\n\nexport function deleteDir(path: string): void {\n  if (fs.existsSync(path)) {\n    fs.readdirSync(path).forEach(function (file) {\n      const curPath = path + \"/\" + file;\n      if (fs.lstatSync(curPath).isDirectory()) {\n        // recurse\n        deleteDir(curPath);\n      } else {\